<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Learning_Planning]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>Learning_Planning</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sat, 11 May 2024 03:46:58 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 11 May 2024 03:46:57 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Tuff Blog]]></title><description><![CDATA[ 
 <br>When i first started in 2020 with attempting to make a game, I barely knew any C. All I had done up to this point was write an x86 bootloader in assembly, attempt to do something in Unity using C# and play around with command line C programs.<br><br><br>This early dive into game and engine development was heavily influenced by Stardew Valley and Pokemon. Everything from the tile based level to the art style.<br><img alt="particleSystem.gif" src="/images/particlesystem.gif"><br>I started off using just SDL2 and learned everything from <a data-tooltip-position="top" aria-label="https://lazyfoo.net/tutorials/SDL/" rel="noopener" class="external-link" href="https://lazyfoo.net/tutorials/SDL/" target="_blank">Lazy Foo's tutorials</a><br>
In the beginning my language of choice was C and that has remained. This is logically a somewhat odd choice but its just personal preference for the simplicity and control i have with C. I could just as easily have done all of this in something more suitable like C++ but wheres the fun in that?<br><img alt="speed.gif" src="/images/speed.gif"><br>After level creation and movement was done, I worked on level interaction and automatic calculation of the borders between tile types. I did these calculations using a method similar to a cellular automaton. Each configuration of the 8 neighbours of a tile is assigned an index into the tilemap below. This later proved to not work too well for intersections of more than 2 materials, but for 2 materials the effect is quite nice.<br>
<img alt="autotile_mask.png" src="/images/autotile_mask.png"><br>
<img alt="fasterEditing.gif" src="/images/fasterediting.gif"><br>I developed an immediate mode (as opposed to a retained mode) UI library from scratch for this project which I used for the inventory and menus. Designing a good UI library is hard.. You'll see this theme come up a couple times again when I talk about my 3D engine as well. The UI of this game was very bare bones and crude but it worked well enough for my uses.<br><img alt="pause.gif" src="/images/pause.gif"><br>
<img alt="checkbox.gif" src="/images/checkbox.gif"><br>I then used this UI system to make a cute little inventory system which served absolutely no purpose. Well, it would've served a purpose if i'd had any planning for the direction the game should've taken. But, alas, I had no idea what I was doing. <br><img alt="itemDrop.gif" src="/images/itemdrop.gif"><br>
<img alt="groundItems.gif" src="/images/grounditems.gif"><br>This project was ended when I attempted to expand the game to support a fully procedurally generated map. By this point the code base was a mess and memory leaks were popping up like a game of whack-a-mole (I got pretty far considering this was my first project of this scale).<br>Although this game never ended up coming to anything, it taught me an incredible amount about basic programming, C, and engine development. This game is the catalyst which later drove me to make a 3D game engine. I deem this project was a success, even though there was no end goal to begin with.<br><br><br>Originally, the only reason i wanted to switch to opengl was so I could rotate sprites in FoxandBox, but I was too tempted by the ability to go 3D. <br><img alt="opengl_renderer.gif" src="/images/opengl_renderer.gif"><br>
<img alt="slider.gif" src="/images/slider.gif"><br>I used the wonderfully well made site <a data-tooltip-position="top" aria-label="https://learnopengl.com/" rel="noopener" class="external-link" href="https://learnopengl.com/" target="_blank">LearnOpenGL</a> by Joey de Vries to get started with basic 3D rendering. Once i'd gotten a fairly loose grasp on using opengl and toyed around with writing some shaders, my priorities changed, I no longer wanted to make a game, I wanted to make a game engine instead.<br>By this point I had a comfortable grasp of most of C and abided by a fair amount of good coding practices (not enough). I went through and worked my way through the tutorial series. Starting off with .obj 3D model parsing / loading. Doing this early on helped immensely with mentally mapping from a 3D object and its triangles to the vertex data the GPU takes in.<br><img alt="crate.gif" src="/images/crate.gif"><br>I followed the tutorials up to the point of basic specular lighting and then toyed around with some different models and normal / bump maps.<br><img alt="more_lighting.gif" src="/images/more_lighting.gif"><br>
<img alt="shiny.gif" src="/images/shiny.gif"><br>Now comes the second attempt at a UI library. This time I went with a retained mode UI and modeled it after a meld of html and css into a single JSON file. I used <a data-tooltip-position="top" aria-label="https://github.com/zserge/jsmn" rel="noopener" class="external-link" href="https://github.com/zserge/jsmn" target="_blank">JSMN</a> to tokenize JSON files and then parsed the contents from there.<br>I needed to change up my approach if i wanted to have a usable program with hot reloading and no memory leaks<br>At this point, I wasn't following the tutorials on LearnOpenGL in order, I was using it more as a reference whenever I wanted to figure out how to do something. I spent a while messing around with shaders since you can very easily get some incredibly complex effects. Heres a few of my favourite:]]></description><link>tuff-blog.html</link><guid isPermaLink="false">Tuff Blog.md</guid><pubDate>Sat, 11 May 2024 03:34:13 GMT</pubDate><enclosure url="images/particlesystem.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/particlesystem.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>